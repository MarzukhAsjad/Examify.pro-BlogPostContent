{
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyHour"
            }
          ]
        },
        "triggerOn": "specificFolder",
        "folderToWatch": {
          "__rl": true,
          "value": "13QWBCMlAPeTd2UKpTDOsAGFefJBmJFIA",
          "mode": "list",
          "cachedResultName": "blogcontent",
          "cachedResultUrl": "https://drive.google.com/drive/folders/13QWBCMlAPeTd2UKpTDOsAGFefJBmJFIA"
        },
        "event": "fileCreated",
        "options": {}
      },
      "type": "n8n-nodes-base.googleDriveTrigger",
      "typeVersion": 1,
      "position": [-2400, 2736],
      "id": "google-drive-trigger",
      "name": "Google Drive Trigger",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "2vg1fSo8hu2qFmjI",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": "={{ $json.id }}",
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [-2200, 2736],
      "id": "download-google-doc",
      "name": "Download Google Doc",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "2vg1fSo8hu2qFmjI",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Parse Google Doc content and extract text with formatting\nconst docContent = Buffer.from($input.first().json.data, 'base64').toString('utf8');\nconst fileName = $input.first().json.name;\n\n// Extract text content from Google Doc\n// Google Docs are typically in HTML format, so we need to parse it\nlet textContent = docContent;\n\n// Basic HTML tag removal for Google Doc content\n// Remove HTML tags but preserve line breaks\ntextContent = textContent\n  .replace(/<\\/?[^>]+(>|$)/g, '\\n') // Remove HTML tags\n  .replace(/\\n\\s*\\n/g, '\\n') // Remove extra line breaks\n  .trim();\n\n// Determine content type based on filename\nlet contentType = 'unknown';\nif (fileName.includes('C_auto')) {\n  contentType = 'blogPost';\n} else if (fileName.includes('P_auto')) {\n  contentType = 'blogPreview';\n}\n\nreturn [{ json: {\n  rawContent: textContent,\n  fileName: fileName,\n  contentType: contentType,\n  docId: $input.first().json.id\n} }];"
      },
      "id": "parse-google-doc",
      "name": "Parse Google Doc",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [-2000, 2736]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Parse Google Doc').item.json.fileName }}",
                    "rightValue": "C_auto",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    },
                    "id": "content-condition"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "content"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "preview-condition",
                    "leftValue": "={{ $('Parse Google Doc').item.json.fileName }}",
                    "rightValue": "P_auto",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "preview"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [-1800, 2736],
      "id": "content-preview-switch",
      "name": "Content/Preview Switch"
    },
    {
      "parameters": {
        "authentication": "apiKey",
        "model": "gpt-4",
        "prompt": "You are an expert TypeScript developer. Convert the following Google Doc content into a TypeScript object that matches the BlogPostContent interface.\n\nGoogle Doc Content:\n{{ $json.rawContent }}\n\nRequirements:\n1. Extract the title, slug, date, excerpt, and content from the Google Doc\n2. Generate a URL-friendly slug from the title if not provided\n3. Format the date as YYYY-MM-DD if not provided\n4. Create a richContent array with the formatted content\n5. Preserve any bold/italic formatting as markdown\n6. Ensure all required fields are present\n7. Return ONLY the TypeScript object, no explanations\n\nExpected BlogPostContent structure:\n{\n  slug: string,\n  title: string,\n  date: string,\n  excerpt: string,\n  content: string,\n  richContent: RichContentBlock[],\n  image?: string,\n  tags?: string[]\n}\n\nRichContentBlock structure:\n{\n  type: 'paragraph' | 'heading' | 'list' | 'code' | 'image',\n  content: string,\n  level?: number (for headings)\n}",
        "options": {
          "temperature": 0.3,
          "maxTokens": 4000
        }
      },
      "id": "ai-content-converter",
      "name": "AI Content Converter",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [-1600, 2608],
      "credentials": {
        "openAiApi": {
          "id": "openai-api-credential",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "authentication": "apiKey",
        "model": "gpt-4",
        "prompt": "You are an expert TypeScript developer. Convert the following Google Doc content into a TypeScript object that matches the BlogPreview interface.\n\nGoogle Doc Content:\n{{ $json.rawContent }}\n\nRequirements:\n1. Extract the title, slug, date, and excerpt from the Google Doc\n2. Generate a URL-friendly slug from the title if not provided\n3. Format the date as YYYY-MM-DD if not provided\n4. Create a concise excerpt (max 200 characters)\n5. Ensure all required fields are present\n6. Return ONLY the TypeScript object, no explanations\n\nExpected BlogPreview structure:\n{\n  slug: string,\n  title: string,\n  date: string,\n  excerpt: string,\n  image?: string,\n  tags?: string[]\n}",
        "options": {
          "temperature": 0.3,
          "maxTokens": 2000
        }
      },
      "id": "ai-preview-converter",
      "name": "AI Preview Converter",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [-1600, 2864],
      "credentials": {
        "openAiApi": {
          "id": "openai-api-credential",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Parse AI response and extract TypeScript object\nconst aiResponse = $input.first().json.text;\n\ntry {\n  // Remove any markdown code blocks\n  let cleanedResponse = aiResponse.replace(/```typescript\\s*|```\\s*|```js\\s*/g, '').trim();\n  \n  // If the response starts with 'export const', extract the object\n  if (cleanedResponse.includes('export const')) {\n    const match = cleanedResponse.match(/export const \\w+\\s*=\\s*(\\{[\\s\\S]*?\\});/);\n    if (match) {\n      cleanedResponse = match[1];\n    }\n  }\n  \n  // Parse the JSON object\n  const parsedObject = JSON.parse(cleanedResponse);\n  \n  // Validate required fields for BlogPostContent\n  const requiredFields = ['slug', 'title', 'date', 'excerpt', 'content', 'richContent'];\n  const missingFields = requiredFields.filter(field => !parsedObject[field]);\n  \n  if (missingFields.length > 0) {\n    throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n  }\n  \n  return [{ json: {\n    parsedContent: parsedObject,\n    isValid: true,\n    contentType: 'blogPost',\n    fileName: $input.first().json.fileName\n  } }];\n  \n} catch (error) {\n  throw new Error(`Failed to parse AI response: ${error.message}\\n\\nAI Response: ${aiResponse}`);\n}"
      },
      "id": "parse-ai-content",
      "name": "Parse AI Content",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [-1400, 2608]
    },
    {
      "parameters": {
        "functionCode": "// Parse AI response and extract TypeScript object\nconst aiResponse = $input.first().json.text;\n\ntry {\n  // Remove any markdown code blocks\n  let cleanedResponse = aiResponse.replace(/```typescript\\s*|```\\s*|```js\\s*/g, '').trim();\n  \n  // If the response starts with 'export const', extract the object\n  if (cleanedResponse.includes('export const')) {\n    const match = cleanedResponse.match(/export const \\w+\\s*=\\s*(\\{[\\s\\S]*?\\});/);\n    if (match) {\n      cleanedResponse = match[1];\n    }\n  }\n  \n  // Parse the JSON object\n  const parsedObject = JSON.parse(cleanedResponse);\n  \n  // Validate required fields for BlogPreview\n  const requiredFields = ['slug', 'title', 'date', 'excerpt'];\n  const missingFields = requiredFields.filter(field => !parsedObject[field]);\n  \n  if (missingFields.length > 0) {\n    throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n  }\n  \n  return [{ json: {\n    parsedContent: parsedObject,\n    isValid: true,\n    contentType: 'blogPreview',\n    fileName: $input.first().json.fileName\n  } }];\n  \n} catch (error) {\n  throw new Error(`Failed to parse AI response: ${error.message}\\n\\nAI Response: ${aiResponse}`);\n}"
      },
      "id": "parse-ai-preview",
      "name": "Parse AI Preview",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [-1400, 2864]
    },
    {
      "parameters": {
        "resource": "file",
        "operation": "get",
        "owner": "chefmatteo",
        "repository": "Examify.pro-BlogPostContent",
        "filePath": "data/blogPostContent.ts",
        "additionalParameters": {}
      },
      "id": "get-github-content",
      "name": "Get GitHub blogPostContent.ts",
      "type": "n8n-nodes-base.github",
      "typeVersion": 1,
      "position": [-1200, 2608],
      "credentials": {
        "githubApi": {
          "id": "xPxf1slGiyx1TGdN",
          "name": "chefmatteo_testing_blog_integration"
        }
      }
    },
    {
      "parameters": {
        "resource": "file",
        "operation": "get",
        "owner": "chefmatteo",
        "repository": "Examify.pro-BlogPostContent",
        "filePath": "data/blogPreviews.ts",
        "additionalParameters": {}
      },
      "id": "get-github-previews",
      "name": "Get GitHub blogPreviews.ts",
      "type": "n8n-nodes-base.github",
      "typeVersion": 1,
      "position": [-1200, 2864],
      "credentials": {
                 "githubApi": {
           "id": "xPxf1slGiyx1TGdN",
           "name": "chefmatteo_testing_blog_integration"
         }
       }
     },
     {
       "parameters": {
         "functionCode": "// Extract existing content from GitHub and merge with new content\nconst githubContent = Buffer.from($input.first().json.content, 'base64').toString('utf8');\nconst newContent = $('Parse AI Content').item.json.parsedContent;\n\n// Extract existing blogPostContent array\nconst contentMatch = githubContent.match(/export const blogPostContent\\s*=\\s*(\\[.*?\\]);/s);\nlet existingContent = [];\n\nif (contentMatch) {\n  try {\n    existingContent = JSON.parse(contentMatch[1]);\n  } catch (error) {\n    throw new Error(`Failed to parse existing GitHub content: ${error.message}`);\n  }\n}\n\n// Check for duplicate slug\nconst existingSlugs = existingContent.map(item => item.slug);\nif (existingSlugs.includes(newContent.slug)) {\n  throw new Error(`Blog post with slug '${newContent.slug}' already exists`);\n}\n\n// Merge content\nconst mergedContent = [...existingContent, newContent];\n\n// Generate updated TypeScript file\nconst updatedFile = `export const blogPostContent = ${JSON.stringify(mergedContent, null, 2)};`;\n\nreturn [{ json: {\n  updatedContent: updatedFile,\n  newPost: newContent,\n  totalPosts: mergedContent.length,\n  contentType: 'blogPost'\n} }];"
       },
       "id": "merge-content-with-github",
       "name": "Merge Content with GitHub",
       "type": "n8n-nodes-base.function",
       "typeVersion": 1,
       "position": [-1000, 2608]
     },
     {
       "parameters": {
         "functionCode": "// Extract existing previews from GitHub and merge with new preview\nconst githubContent = Buffer.from($input.first().json.content, 'base64').toString('utf8');\nconst newPreview = $('Parse AI Preview').item.json.parsedContent;\n\n// Extract existing blogPreviews array\nconst contentMatch = githubContent.match(/export const blogPreviews\\s*=\\s*(\\[.*?\\]);/s);\nlet existingPreviews = [];\n\nif (contentMatch) {\n  try {\n    existingPreviews = JSON.parse(contentMatch[1]);\n  } catch (error) {\n    throw new Error(`Failed to parse existing GitHub previews: ${error.message}`);\n  }\n}\n\n// Check for duplicate slug\nconst existingSlugs = existingPreviews.map(item => item.slug);\nif (existingSlugs.includes(newPreview.slug)) {\n  throw new Error(`Blog preview with slug '${newPreview.slug}' already exists`);\n}\n\n// Merge content\nconst mergedPreviews = [...existingPreviews, newPreview];\n\n// Generate updated TypeScript file\nconst updatedFile = `export const blogPreviews = ${JSON.stringify(mergedPreviews, null, 2)};`;\n\nreturn [{ json: {\n  updatedContent: updatedFile,\n  newPreview: newPreview,\n  totalPreviews: mergedPreviews.length,\n  contentType: 'blogPreview'\n} }];"
       },
       "id": "merge-preview-with-github",
       "name": "Merge Preview with GitHub",
       "type": "n8n-nodes-base.function",
       "typeVersion": 1,
       "position": [-1000, 2864]
     },
     {
       "parameters": {
         "resource": "file",
         "operation": "edit",
         "owner": "chefmatteo",
         "repository": "Examify.pro-BlogPostContent",
         "filePath": "data/blogPostContent.ts",
         "fileContent": "={{ $json.updatedContent }}",
         "commitMessage": "Auto-merge AI-generated blog post from Google Doc: {{ $json.newPost.slug }}"
       },
       "id": "update-github-content",
       "name": "Update GitHub Content",
       "type": "n8n-nodes-base.github",
       "typeVersion": 1,
       "position": [-800, 2608],
       "credentials": {
         "githubApi": {
           "id": "xPxf1slGiyx1TGdN",
           "name": "chefmatteo_testing_blog_integration"
         }
       }
     },
     {
       "parameters": {
         "resource": "file",
         "operation": "edit",
         "owner": "chefmatteo",
         "repository": "Examify.pro-BlogPostContent",
         "filePath": "data/blogPreviews.ts",
         "fileContent": "={{ $json.updatedContent }}",
         "commitMessage": "Auto-merge AI-generated blog preview from Google Doc: {{ $json.newPreview.slug }}"
       },
       "id": "update-github-preview",
       "name": "Update GitHub Preview",
       "type": "n8n-nodes-base.github",
       "typeVersion": 1,
       "position": [-800, 2864],
       "credentials": {
         "githubApi": {
           "id": "xPxf1slGiyx1TGdN",
           "name": "chefmatteo_testing_blog_integration"
         }
       }
     },
     {
       "parameters": {
         "functionCode": "// Log successful content update\nconst newPost = $('Merge Content with GitHub').item.json.newPost;\nconst totalPosts = $('Merge Content with GitHub').item.json.totalPosts;\n\nreturn [{ json: {\n  message: `Successfully processed and merged new blog post: ${newPost.slug}`,\n  title: newPost.title,\n  totalPosts: totalPosts,\n  timestamp: new Date().toISOString(),\n  action: 'content_merge_success'\n} }];"
       },
       "id": "log-content-success",
       "name": "Log Content Success",
       "type": "n8n-nodes-base.function",
       "typeVersion": 1,
       "position": [-600, 2608]
     },
     {
       "parameters": {
         "functionCode": "// Log successful preview update\nconst newPreview = $('Merge Preview with GitHub').item.json.newPreview;\nconst totalPreviews = $('Merge Preview with GitHub').item.json.totalPreviews;\n\nreturn [{ json: {\n  message: `Successfully processed and merged new blog preview: ${newPreview.slug}`,\n  title: newPreview.title,\n  totalPreviews: totalPreviews,\n  timestamp: new Date().toISOString(),\n  action: 'preview_merge_success'\n} }];"
       },
       "id": "log-preview-success",
       "name": "Log Preview Success",
       "type": "n8n-nodes-base.function",
       "typeVersion": 1,
       "position": [-600, 2864]
     },
     {
       "parameters": {
         "functionCode": "// Log error for invalid file type\nreturn [{ json: {\n  message: 'Invalid file type - must contain C_auto for content or P_auto for preview',\n  fileName: $input.first().json.name,\n  timestamp: new Date().toISOString(),\n  action: 'invalid_file_type'\n} }];"
       },
       "id": "log-invalid-file",
       "name": "Log Invalid File",
       "type": "n8n-nodes-base.function",
       "typeVersion": 1,
       "position": [-600, 3008]
     }
  ],
  "connections": {
    "Google Drive Trigger": {
      "main": [
        [
          {
            "node": "Download Google Doc",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Google Doc": {
      "main": [
        [
          {
            "node": "Parse Google Doc",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Google Doc": {
      "main": [
        [
          {
            "node": "Content/Preview Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Content/Preview Switch": {
      "main": [
        [
          {
            "node": "AI Content Converter",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AI Preview Converter",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Log Invalid File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Content Converter": {
      "main": [
        [
          {
            "node": "Parse AI Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Preview Converter": {
      "main": [
        [
          {
            "node": "Parse AI Preview",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Content": {
      "main": [
        [
          {
            "node": "Get GitHub blogPostContent.ts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Preview": {
      "main": [
        [
          {
            "node": "Get GitHub blogPreviews.ts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get GitHub blogPostContent.ts": {
      "main": [
        [
          {
            "node": "Merge Content with GitHub",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get GitHub blogPreviews.ts": {
      "main": [
        [
          {
            "node": "Merge Preview with GitHub",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Content with GitHub": {
      "main": [
        [
          {
            "node": "Update GitHub Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Preview with GitHub": {
      "main": [
        [
          {
            "node": "Update GitHub Preview",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update GitHub Content": {
      "main": [
        [
          {
            "node": "Log Content Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update GitHub Preview": {
      "main": [
        [
          {
            "node": "Log Preview Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "ai-powered-blog-workflow"
  }
}
