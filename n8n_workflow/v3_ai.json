{
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyHour"
            }
          ]
        },
        "triggerOn": "specificFolder",
        "folderToWatch": {
          "__rl": true,
          "value": "13QWBCMlAPeTd2UKpTDOsAGFefJBmJFIA",
          "mode": "list",
          "cachedResultName": "blogcontent",
          "cachedResultUrl": "https://drive.google.com/drive/folders/13QWBCMlAPeTd2UKpTDOsAGFefJBmJFIA"
        },
        "event": "fileCreated",
        "options": {}
      },
      "type": "n8n-nodes-base.googleDriveTrigger",
      "typeVersion": 1,
      "position": [-2400, 2736],
      "id": "google-drive-trigger",
      "name": "Google Drive Trigger",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "2vg1fSo8hu2qFmjI",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": "={{ $json.id }}",
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [-2200, 2736],
      "id": "download-google-doc",
      "name": "Download Google Doc",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "2vg1fSo8hu2qFmjI",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Parse Google Doc content and extract text with formatting\nconst docContent = Buffer.from($input.first().json.data, 'base64').toString('utf8');\nconst fileName = $input.first().json.name;\n\n// Extract text content from Google Doc\n// Google Docs are typically in HTML format, so we need to parse it\nlet textContent = docContent;\n\n// Basic HTML tag removal for Google Doc content\n// Remove HTML tags but preserve line breaks\ntextContent = textContent\n  .replace(/<\\/?[^>]+(>|$)/g, '\\n') // Remove HTML tags\n  .replace(/\\n\\s*\\n/g, '\\n') // Remove extra line breaks\n  .trim();\n\n// Determine content type based on filename\nlet contentType = 'unknown';\nif (fileName.includes('C_auto')) {\n  contentType = 'blogPost';\n} else if (fileName.includes('P_auto')) {\n  contentType = 'blogPreview';\n}\n\nreturn [{ json: {\n  rawContent: textContent,\n  fileName: fileName,\n  contentType: contentType,\n  docId: $input.first().json.id\n} }];"
      },
      "id": "parse-google-doc",
      "name": "Parse Google Doc",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [-2000, 2736]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Parse Google Doc').item.json.fileName }}",
                    "rightValue": "C_auto",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    },
                    "id": "content-condition"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "content"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "preview-condition",
                    "leftValue": "={{ $('Parse Google Doc').item.json.fileName }}",
                    "rightValue": "P_auto",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "preview"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [-1800, 2736],
      "id": "content-preview-switch",
      "name": "Content/Preview Switch"
    },
    {
      "parameters": {
        "authentication": "apiKey",
        "model": "gpt-4",
        "prompt": "You are an expert TypeScript developer. Convert the following Google Doc content into a TypeScript object that matches the BlogPostContent interface.\n\nGoogle Doc Content:\n{{ $json.rawContent }}\n\nRequirements:\n1. Extract the title, slug, date, excerpt, and content from the Google Doc\n2. Generate a URL-friendly slug from the title if not provided\n3. Format the date as YYYY-MM-DD if not provided\n4. Create a richContent array with the formatted content\n5. Preserve any bold/italic formatting as markdown\n6. Ensure all required fields are present\n7. Return ONLY the TypeScript object, no explanations\n\nExpected BlogPostContent structure:\n{\n  slug: string,\n  title: string,\n  date: string,\n  excerpt: string,\n  content: string,\n  richContent: RichContentBlock[],\n  image?: string,\n  tags?: string[]\n}\n\nRichContentBlock structure:\n{\n  type: 'paragraph' | 'heading' | 'list' | 'code' | 'image',\n  content: string,\n  level?: number (for headings)\n}",
        "options": {
          "temperature": 0.3,
          "maxTokens": 4000
        }
      },
      "id": "ai-content-converter",
      "name": "AI Content Converter",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [-1600, 2608],
      "credentials": {
        "openAiApi": {
          "id": "openai-api-credential",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "authentication": "apiKey",
        "model": "gpt-4",
        "prompt": "You are an expert TypeScript developer. Convert the following Google Doc content into a TypeScript object that matches the BlogPreview interface.\n\nGoogle Doc Content:\n{{ $json.rawContent }}\n\nRequirements:\n1. Extract the title, slug, date, and excerpt from the Google Doc\n2. Generate a URL-friendly slug from the title if not provided\n3. Format the date as YYYY-MM-DD if not provided\n4. Create a compelling excerpt (max 200 characters)\n5. If excerpt is missing or too short, generate a compelling excerpt from the content\n6. Ensure all required fields are present\n7. Return ONLY the TypeScript object, no explanations\n\nExpected BlogPreview structure:\n{\n  slug: string,\n  title: string,\n  date: string,\n  excerpt: string,\n  image?: string,\n  tags?: string[]\n}",
        "options": {
          "temperature": 0.3,
          "maxTokens": 2000
        }
      },
      "id": "ai-preview-converter",
      "name": "AI Preview Converter",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [-1600, 2864],
      "credentials": {
        "openAiApi": {
          "id": "openai-api-credential",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Parse AI response and extract TypeScript object\nconst aiResponse = $input.first().json.text;\n\ntry {\n  // Remove any markdown code blocks\n  let cleanedResponse = aiResponse.replace(/```typescript\\s*|```\\s*|```js\\s*/g, '').trim();\n  \n  // If the response starts with 'export const', extract the object\n  if (cleanedResponse.includes('export const')) {\n    const match = cleanedResponse.match(/export const \\w+\\s*=\\s*(\\{[\\s\\S]*?\\});/);\n    if (match) {\n      cleanedResponse = match[1];\n    }\n  }\n  \n  // Parse the JSON object\n  const parsedObject = JSON.parse(cleanedResponse);\n  \n  // Validate required fields for BlogPostContent\n  const requiredFields = ['slug', 'title', 'date', 'excerpt', 'content', 'richContent'];\n  const missingFields = requiredFields.filter(field => !parsedObject[field]);\n  \n  if (missingFields.length > 0) {\n    throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n  }\n  \n  return [{ json: {\n    parsedContent: parsedObject,\n    isValid: true,\n    contentType: 'blogPost',\n    fileName: $input.first().json.fileName\n  } }];\n  \n} catch (error) {\n  throw new Error(`Failed to parse AI response: ${error.message}\\n\\nAI Response: ${aiResponse}`);\n}"
      },
      "id": "parse-ai-content",
      "name": "Parse AI Content",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [-1400, 2608]
    },
    {
      "parameters": {
        "functionCode": "// Parse AI response and extract TypeScript object\nconst aiResponse = $input.first().json.text;\n\ntry {\n  // Remove any markdown code blocks\n  let cleanedResponse = aiResponse.replace(/```typescript\\s*|```\\s*|```js\\s*/g, '').trim();\n  \n  // If the response starts with 'export const', extract the object\n  if (cleanedResponse.includes('export const')) {\n    const match = cleanedResponse.match(/export const \\w+\\s*=\\s*(\\{[\\s\\S]*?\\});/);\n    if (match) {\n      cleanedResponse = match[1];\n    }\n  }\n  \n  // Parse the JSON object\n  const parsedObject = JSON.parse(cleanedResponse);\n  \n  // Validate required fields for BlogPreview\n  const requiredFields = ['slug', 'title', 'date', 'excerpt'];\n  const missingFields = requiredFields.filter(field => !parsedObject[field]);\n  \n  if (missingFields.length > 0) {\n    throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n  }\n  \n  return [{ json: {\n    parsedContent: parsedObject,\n    isValid: true,\n    contentType: 'blogPreview',\n    fileName: $input.first().json.fileName\n  } }];\n  \n} catch (error) {\n  throw new Error(`Failed to parse AI response: ${error.message}\\n\\nAI Response: ${aiResponse}`);\n}"
      },
      "id": "parse-ai-preview",
      "name": "Parse AI Preview",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [-1400, 2864]
    },
    {
      "parameters": {
        "keepOnlySet": true,
        "values": {
          "string": [
            {
              "name": "commitDate",
              "value": "={{ $json.formattedDate }}"
            }
          ]
        },
        "options": {}
      },
      "id": "set-commit-date",
      "name": "Set commit date",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [-1200, 2736]
    },
    {
      "parameters": {
        "model": "anthropic/claude-3.7-sonnet:thinking",
        "options": {
          "responseFormat": "json_object"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [-1000, 2736],
      "id": "openrouter-chat-model",
      "name": "OpenRouter Chat Model",
      "credentials": {
                 "openRouterApi": {
           "id": "2VmSLybh4blgPyNI",
           "name": "OpenRouter account"
         }
       }
     },
     {
       "parameters": {
         "promptType": "define",
         "text": "=You are a bot that excels in merging codes. I will give you a code snippet which represents a blog post (the actual content) or a preview (preview of a blog, like a thumbnail). When the snippet is a blog content code, you will merge it to the blogPostContent.ts file. When the snippet is blog preview code, you will merge it to the blogPreviews.ts file. You may analyse the blogPostContent.ts or blogPreviews.ts first using the tools below to understand which file to add it to and where in which line. Then once it's done, I want you to give me the final merged blogPostContent.ts or blogPreviews.ts. This will be in json format. One field will be the `filename`, which will say if it either *blogPostContent.ts* or *blogPreviews.ts*. The other field `code` will contain the fully merged code of the new file.\n\n```snippet (you can specify whether it's preview or postContent dynamically in runtime with incoming node information)\n{{ $json.parsedContent }}\n```\n\nContent Type: {{ $json.contentType }}\n\nYou have the following tools to use:\n1. get_current_blog_preview - Gets the current blogPreviews.ts file content from GitHub\n2. get_current_blog_post_content - Gets the current blogPostContent.ts file content from GitHub\n3. update_code - Updates the specified file in GitHub with new content\n4. notify_via_discord - Sends a Discord notification about the operation result\n\n--> For formatting the payload, you can either refer to the [official Discord docs](https://discord.com/developers/docs/resources/webhook#execute-webhook) or this [cool tool to convert previews to jsons](https://toolscord.com/webhook)",
         "options": {}
       },
       "type": "@n8n/n8n-nodes-langchain.agent",
       "typeVersion": 2.2,
       "position": [-1000, 2608],
       "id": "code-merge-agent",
       "name": "Code Merge Agent"
     },
     {
       "parameters": {
         "resource": "file",
         "operation": "get",
         "owner": "chefmatteo",
         "repository": "Examify.pro-BlogPostContent",
         "filePath": "data/blogPostContent.ts",
         "additionalParameters": {}
       },
       "id": "get-current-blog-post-content",
       "name": "Get Current Blog Post Content",
       "type": "n8n-nodes-base.github",
       "typeVersion": 1,
       "position": [-800, 2608],
       "credentials": {
         "githubApi": {
           "id": "xPxf1slGiyx1TGdN",
           "name": "chefmatteo_testing_blog_integration"
         }
       }
     },
     {
       "parameters": {
         "resource": "file",
         "operation": "get",
         "owner": "chefmatteo",
         "repository": "Examify.pro-BlogPostContent",
         "filePath": "data/blogPreviews.ts",
         "additionalParameters": {}
       },
       "id": "get-current-blog-preview",
       "name": "Get Current Blog Preview",
       "type": "n8n-nodes-base.github",
       "typeVersion": 1,
       "position": [-800, 2864],
       "credentials": {
         "githubApi": {
           "id": "xPxf1slGiyx1TGdN",
           "name": "chefmatteo_testing_blog_integration"
         }
       }
     },
     {
       "parameters": {
         "resource": "file",
         "operation": "edit",
         "owner": "chefmatteo",
         "repository": "Examify.pro-BlogPostContent",
         "filePath": "={{ $json.filename }}",
         "fileContent": "={{ $json.code }}",
         "commitMessage": "Auto-merge AI-generated content: {{ $json.commitDate }}"
       },
       "id": "update-code",
       "name": "Update Code",
       "type": "n8n-nodes-base.github",
       "typeVersion": 1,
       "position": [-600, 2736],
       "credentials": {
         "githubApi": {
           "id": "xPxf1slGiyx1TGdN",
           "name": "chefmatteo_testing_blog_integration"
         }
       }
     },
     {
       "parameters": {
         "method": "POST",
         "url": "https://discord.com/api/webhooks/1410105152819429386/R-skMAbCsJKWHPIpCiiXGXEoJJMC4KuPrqVIskKxUE57Rc4qkWwjz9oiNhdIH6VvkOhV",
         "sendBody": true,
         "specifyBody": "json",
         "jsonBody": "{\n  \"embeds\": [\n    {\n      \"title\": \"Blog Content Update\",\n      \"description\": \"{{ $json.message }}\",\n      \"color\": 16711680,\n      \"footer\": {\n        \"text\": \"AI-Powered Blog Automation\"\n      },\n      \"author\": {\n        \"name\": \"n8n Workflow\"\n      },\n      \"fields\": [\n        {\n          \"name\": \"Status\",\n          \"value\": \"{{ $json.status }}\",\n          \"inline\": true\n        },\n        {\n          \"name\": \"File\",\n          \"value\": \"{{ $json.filename }}\",\n          \"inline\": true\n        }\n      ]\n    }\n  ]\n}",
         "options": {}
       },
       "type": "n8n-nodes-base.httpRequest",
       "typeVersion": 4.2,
       "position": [-400, 2736],
       "id": "notify-via-discord",
       "name": "Notify via Discord"
     },
     {
       "parameters": {
         "functionCode": "// Log error for invalid file type\nreturn [{ json: {\n  message: 'Invalid file type - must contain C_auto for content or P_auto for preview',\n  fileName: $input.first().json.name,\n  timestamp: new Date().toISOString(),\n  action: 'invalid_file_type',\n  status: 'Error',\n  filename: 'N/A'\n} }];"
       },
       "id": "log-invalid-file",
       "name": "Log Invalid File",
       "type": "n8n-nodes-base.function",
       "typeVersion": 1,
       "position": [-400, 3008]
     }
  ],
  "connections": {
    "Google Drive Trigger": {
      "main": [
        [
          {
            "node": "Download Google Doc",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Google Doc": {
      "main": [
        [
          {
            "node": "Parse Google Doc",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Google Doc": {
      "main": [
        [
          {
            "node": "Content/Preview Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Content/Preview Switch": {
      "main": [
        [
          {
            "node": "AI Content Converter",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AI Preview Converter",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Log Invalid File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Content Converter": {
      "main": [
        [
          {
            "node": "Parse AI Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Preview Converter": {
      "main": [
        [
          {
            "node": "Parse AI Preview",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Content": {
      "main": [
        [
          {
            "node": "Set commit date",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Preview": {
      "main": [
        [
          {
            "node": "Set commit date",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set commit date": {
      "main": [
        [
          {
            "node": "Code Merge Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Code Merge Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Code Merge Agent": {
      "ai_tool": [
        [
          {
            "node": "Get Current Blog Post Content",
            "type": "ai_tool",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Current Blog Preview",
            "type": "ai_tool",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Code",
            "type": "ai_tool",
            "index": 0
          }
        ],
        [
          {
            "node": "Notify via Discord",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Get Current Blog Post Content": {
      "ai_tool": [
        [
          {
            "node": "Code Merge Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Get Current Blog Preview": {
      "ai_tool": [
        [
          {
            "node": "Code Merge Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Update Code": {
      "ai_tool": [
        [
          {
            "node": "Code Merge Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Notify via Discord": {
      "ai_tool": [
        [
          {
            "node": "Code Merge Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Log Invalid File": {
      "main": [
        [
          {
            "node": "Notify via Discord",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "ai-powered-blog-workflow"
  }
}
